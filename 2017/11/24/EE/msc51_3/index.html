<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>单片机原理(3)：中断、定时/计数、串行通信 - Cornfield Chase</title><link rel="manifest" href="/manifest.json"><meta name="theme-color" content="#B481BB"><meta name="application-name" content="Hugsy&#039;s Blog"><meta name="msapplication-TileImage" content="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/favicon.svg"><meta name="msapplication-TileColor" content="#B481BB"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Hugsy&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><link rel="apple-touch-icon" sizes="144x144" href="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/favicon.svg"><meta name="description" content="中断（Interrupt）是指在计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。 定时器&amp;#x2F;计数器（Timer&amp;#x2F;Counter）在实时控制系统中，实现对于外界事件的定时延时及计数功能。 串行通信（Serial Communicate）是计算机与外界交换信息的一种基本通信方式。"><meta property="og:type" content="blog"><meta property="og:title" content="单片机原理(3)：中断、定时/计数、串行通信"><meta property="og:url" content="https://hugsy.top/2017/11/24/EE/msc51_3/"><meta property="og:site_name" content="Cornfield Chase"><meta property="og:description" content="中断（Interrupt）是指在计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。 定时器&amp;#x2F;计数器（Timer&amp;#x2F;Counter）在实时控制系统中，实现对于外界事件的定时延时及计数功能。 串行通信（Serial Communicate）是计算机与外界交换信息的一种基本通信方式。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411112608.png"><meta property="article:published_time" content="2017-11-23T16:00:00.000Z"><meta property="article:modified_time" content="2022-12-10T09:50:19.188Z"><meta property="article:author" content="Hugsy"><meta property="article:tag" content="EE"><meta property="article:tag" content="MCU"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411112608.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://hugsy.top/2017/11/24/EE/msc51_3/"},"headline":"单片机原理(3)：中断、定时/计数、串行通信","image":["https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411112608.png"],"datePublished":"2017-11-23T16:00:00.000Z","dateModified":"2022-12-10T09:50:19.188Z","author":{"@type":"Person","name":"Hugsy"},"description":"中断（Interrupt）是指在计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。 定时器&#x2F;计数器（Timer&#x2F;Counter）在实时控制系统中，实现对于外界事件的定时延时及计数功能。 串行通信（Serial Communicate）是计算机与外界交换信息的一种基本通信方式。"}</script><link rel="canonical" href="https://hugsy.top/2017/11/24/EE/msc51_3/"><link rel="alternate" href="/atom.xml" title="Cornfield Chase" type="application/atom+xml"><link rel="icon" href="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?7b65ce26b5ae8dae153d7b4d53214ba4";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.2"></head><body class="is-1-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/logo.svg" alt="Cornfield Chase" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/tags/CS/">CS</a><a class="navbar-item" href="/tags/EE/">EE</a><a class="navbar-item" href="/tags/ML/">ML</a><a class="navbar-item" href="/tags/ME/">ME</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-12"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411112608.png" alt="单片机原理(3)：中断、定时/计数、串行通信"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-11-23T16:00:00.000Z" title="11/24/2017, 12:00:00 AM">2017-11-24</time>发表</span><span class="level-item"><time dateTime="2022-12-10T09:50:19.188Z" title="12/10/2022, 5:50:19 PM">2022-12-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span><span class="level-item">1 小时读完 (大约7643个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">单片机原理(3)：中断、定时/计数、串行通信</h1><div class="content"><p><strong>中断（Interrupt）</strong>是指在计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
<p><strong>定时器/计数器（Timer/Counter）</strong>在实时控制系统中，实现对于外界事件的定时延时及计数功能。</p>
<p><strong>串行通信（Serial Communicate）</strong>是计算机与外界交换信息的一种基本通信方式。</p>
<span id="more"></span>

<h2 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h2><p>中断过程中，请求产生中断的事件称为中断源，中断源向CPU提出的请求为中断请求（Interrupt Requst，IRQ），CPU通过上下文切换保存好当前的工作状态后，转而去处理中断请求，也就是产生中断响应。直到处理完中断请求事件，才返回原来的工作状态，继续工作。整个过程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411113510.png" alt="中断过程"></p>
<p>51单片机中断系统的结构图如下：</p>
<p><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411113525.png" alt="中断系统结构"></p>
<h3 id="中断源"><a href="#中断源" class="headerlink" title="中断源"></a>中断源</h3><p>51单片机中有5个中断源，如下表所示：</p>
<table>
<thead>
<tr>
<th>中断号</th>
<th>优先级</th>
<th>中断源</th>
<th>中断入口地址</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>1(最高级)</td>
<td>外部中断0</td>
<td>0003H</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>定时器0</td>
<td>000BH</td>
</tr>
<tr>
<td>2</td>
<td>3</td>
<td>外部中断1</td>
<td>0013H</td>
</tr>
<tr>
<td>3</td>
<td>4</td>
<td>定时器1</td>
<td>001BH</td>
</tr>
<tr>
<td>4</td>
<td>5(最低级)</td>
<td>串口中断</td>
<td>0023H</td>
</tr>
</tbody></table>
<p>每个中断源都分配了对应的中断号及中断服务入口地址，在这个中断入口地址里，存放着跳转到相应中断服务程序的跳转指令。当多个中断源同时向CPU提出中断请求时，CPU将根据中断源的优先级来依次响应中断。</p>
<h3 id="相关寄存器"><a href="#相关寄存器" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><p>SFR中与中断有关的寄存器有：</p>
<h4 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h4><p>**IE(Interrupt Enable)**，中断允许寄存器，可位寻址，其各位定义如下：</p>
<p>位地址 | AFH | AEH | ADH | ACH | ABH | AAH | A9H | A8H<br>——|——|——|——|——|——|——|——|——|——<br>定义    | EA | - | (ET2) | ES | ET1 | EX1 | ET0 | EX0</p>
<ul>
<li>**EA(Enable All)**：CPU中断总控制位，EA=1，CPU对所有中断开放，EA=0，CPU禁止一切中断响应。</li>
<li>**ES(Enable Serial)**：串口中断允许控制位，ES=1，允许串行口接受、发送中断。</li>
<li>**ET0/ET1(Enable Timer)**：定时/计数器0/1中断允许控制位，ET0/ET1=1，允许T0/T1中断。52系列单片机里还有ET2。</li>
<li>**EX0/EX1(Enable Exterior)**：外部中断INT0/INT1中断允许控制位，EX0/EX1=1，允许外部中断INT0/INT1中断。</li>
</ul>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>**IP(Interrupt Priority)**，中断优先级寄存器，可位寻址，其各位定义如下。未设置时或复位后，IP各位均为””则按照系统默认的优先级</p>
<p>位地址 | BFH | BEH | BDH | BCH | BBH | BAH | B9H | B8H<br>——|——|——|——|——|——|——|——|——|——<br>定义     | - | - | (PT2) | PS | PT1 | PX1 | PT0 | PX0</p>
<ul>
<li>**PS(Priority Serial)**：串行口优先级设定位，PS=1，串行口为高优先级。</li>
<li>**PT0/PT1(Priority Timer)**：定时/计数器0/1优先级设定位，PT0/PT1=1，定时/计数器0/1为高优先级。</li>
<li>**PX0/PX1(Priority Exterior)**：外部中断INT0/INT1优先级设定位，PX0/PX1=1，外部中断INT0/INT1为高优先级。</li>
</ul>
<h4 id="TCON"><a href="#TCON" class="headerlink" title="TCON"></a>TCON</h4><p>**TCON(Timer Control)**，定时/计数器控制寄存器，可位寻址，其各位定义如下：</p>
<p>位地址 | 8FH | 8EH | 8DH | 8CH | 8BH | 8AH | 89H | 88H<br>——|——|——|——|——|——|——|——|——|——<br>定义     | TF1 | TR1 | TF0 | TR0 | IE1 | IT1 | IE0 | IT0</p>
<ul>
<li>**TF0/TF1(Timer Flag)**：定时/计数器0/1溢出标志位，当定时/计数器计满溢出时，由硬件自动置“1”，并申请中断；在进入中断服务程序后，又由硬件自动置“0”。</li>
<li>**TR0/TR1(Timer Run)**：定时/计数器0/1启停控制位，TR0/TR1=1，启动定时/计数器。</li>
<li>**IE0/IE1(Interrupt Exterior)**：外部中断INT0/INT1中断请求标志位，外部中断源有请求时，对应的标志位IE0/IE1由硬件置“1”，当CPU响应该中断后，又由硬件自动置“0”。</li>
<li>**IT0/IT1(Interrupt Touch)**：外部中断INT0/INT1的触发方式选择位，IT0/IT1=0，对应外部中断设置为低电平触发方式，IT0/IT1=1，对应外部中断设置为边沿触发方式。</li>
</ul>
<h3 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h3><p>51单片机在CPU的每个机器周期的S5 P2期间，将自动查询TCON中各个中断申请标志，若查询到某个中断标志位被置位，将启动中断机制。</p>
<p>中断源发出中断请求后。要使CPU能够响应中断，IE中的中断总允许位EA及对应的中断允许位（ES/ET/EX）都需要置为“1”。</p>
<p>处理外部中断时，若外部中断设为低电平触发方式，则CPU在每个查询中断申请标志时也将对INTi引脚进行采样，测得INTi=0，则认为有中断申请，随即将IEi标志位置位，否则测得INTi=1，则认为无中断请求，而清除IEi标志位。所以施加在INTi引脚上的低电平持续时间应该大于一个机器周期，且小于中断服务程序得执行时间。</p>
<p>若外部中断设为边沿触发方式，则CPU在每个查询中断申请标志时将对INTi引脚进行采样，若在<strong>连续两个机器周期采样到先高后低的电平变化</strong>，则认为有中断申请，随即将IEi标志位置位，否则测得INTi=1，则认为无中断请求，而清除IEi标志位。所以，为了保证CPU在两个机器周期内能够检测到由高到低跳变得电平，输入的高低电平持续时间至少要保持12个振荡周期（即一个机器周期）时间。</p>
<p>在中断处理过程中，如果正在执行同级或高优先级的中断服务程序，或是正在执行的指令还没完成，则中断响应会受到阻断。51单片机的中断响应时间最短为3个机器周期，其他情况的中断响应时间一般是3~8个周期。</p>
<p>在CPU响应中断后，应该撤除该中断请求，否则会再次产生中断，进入死循环。</p>
<h3 id="中断程序的编写"><a href="#中断程序的编写" class="headerlink" title="中断程序的编写"></a>中断程序的编写</h3><p>由中断的处理过程可知，在编写中断管理与控制程序时应该考虑一下几个方面：</p>
<ul>
<li>CPU开中断和关中断</li>
<li>某个中断源中断请求的允许或屏蔽</li>
<li>各中断源优先级别的设定</li>
<li>外部中断请求的触发方式</li>
</ul>
<p>中断程序基本编写格式如下：</p>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">      ;中断入口设置</span><br><span class="line">      ORG 0000H   ;起始地址</span><br><span class="line">      LJMP MAIN   ;跳转到主程序</span><br><span class="line">      ORG 0003H   ;中断入口地址1</span><br><span class="line">      LJMP INT1    ;跳转到外部中断INT0服务程序</span><br><span class="line">      ORG 000BH   ;中断入口地址2</span><br><span class="line">      LJMP INT2    ;跳转到定时器0中断服务程序，没有则不写或写成“RETI”，下同</span><br><span class="line">      ORG 0013H   ;中断入口地址3</span><br><span class="line">      LJMP INT3    ;跳转到外部中断INT1服务程序</span><br><span class="line">      ORG 001BH   ;中断入口地址4</span><br><span class="line">      LJMP INT4    ;跳转到定时器1中断服务程序</span><br><span class="line">      ORG 0023H    ;中断入口地址5</span><br><span class="line">      LJMP INT5    ;跳转到串口中断服务程序</span><br><span class="line"></span><br><span class="line">      ;主程序</span><br><span class="line">      ORG 0030H   ;起始地址</span><br><span class="line">MAIN: SETB IT0   ;IT0=1，边沿触发</span><br><span class="line">      SETB EA   ;EA=1，开启总中断</span><br><span class="line">      SETB EX0   ;EX0=1，允许外部中断INT0</span><br><span class="line">      ……</span><br><span class="line">LOOP: NOP</span><br><span class="line">      LJMP LOOP   ;死循环</span><br><span class="line"></span><br><span class="line">      ;中断服务程序</span><br><span class="line">      ORG 0100H   ;起始地址</span><br><span class="line">INT1: PUSH ACC   ;保存原来状态，下同</span><br><span class="line">      PUSH PSW  ;</span><br><span class="line">      ……</span><br><span class="line">INT2: ……</span><br><span class="line">      ……</span><br><span class="line">      POP PSW   ;恢复原始状态，下同</span><br><span class="line">      POP ACC   ;</span><br><span class="line">      RETI            ;中断返回</span><br><span class="line"></span><br><span class="line">      END            ;结束</span><br></pre></td></tr></table></figure>

<p>C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  IT0 = <span class="number">1</span>；<span class="comment">//注释同汇编</span></span><br><span class="line">  EX0 = <span class="number">1</span>；</span><br><span class="line">  EA = <span class="number">1</span>；</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理程序</span></span><br><span class="line"><span class="type">void</span> int0() interrupt <span class="number">0</span> &#123;  <span class="comment">// 外部中断INT0服务程序</span></span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定时-计数器"><a href="#定时-计数器" class="headerlink" title="定时/计数器"></a>定时/计数器</h2><p>51单片机内部有两个16位可编程的定时/计数器0和1，分别用T0及T1表示。它们的工作方式、定时时间、量程、启动方式、等均可通过程序来设置和改变。</p>
<p>计数功能用于统计从T0（P3.4）、T1（P3.5）引脚输入的脉冲负跳变数量，每输入一个脉冲负跳变，计数器就加1。负跳变指的是一个机器周期采样为高电平，后一个机器周期采样为低电平。</p>
<p>定时功能是单片机通过对内部机器脉冲信号计数实现的，计数值乘以机器周期即是相应的时间。如单片机采用12MHz晶振，机器内部脉冲频率为1MHz，机器周期为1us，计数1000次，即1ms时间。</p>
<p>当计数值溢出后，定时计数器给出中断请求，进而使CPU去处理中断事件。</p>
<p>51单片机定时/计数器结构如下：</p>
<p><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411113548.png" alt="定时/计数器结构"></p>
<h3 id="相关寄存器-1"><a href="#相关寄存器-1" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><p>除前面介绍过的中断相关寄存器外，SFR中与定时/计数器有关的寄存器有：</p>
<h4 id="TMOD"><a href="#TMOD" class="headerlink" title="TMOD"></a>TMOD</h4><p><strong>TMOD(Timer Mode)<strong>，定时/计数器模式控制寄存器，</strong>不可位寻址</strong>，其各位定义如下。其中TMOD的高半字节D4<del>D7用来控制定时/计数器1，低半字节D0</del>D3用来控制定时/计数器0。</p>
<p>位号 | D7H | D6H | D5H | D4H | D3H | D2H | D1H | D0H<br>——|——|——|——|——|——|——|——|——|——<br>定义     | GATE | C\T | M1 | M0 | GATE | C\T | M1 | M0</p>
<ul>
<li><strong>GATE</strong>：门控制位，用来控制定时/计数器的启动方式。GATE=1，由外部中断引脚INT0/INT1来启动定时器T0/T1， 当INT0/INT1引脚为高电平且TR0/TR1置位，启动定时器T0/T1；GATE=0，仅由TR0/TR1置位而启动定时器T0/T1。</li>
<li><strong>C\T</strong>：功能选择位，C\T=0，为定时模式，计数脉冲由内部提供，计数周期等于机器周期；C\T=1，为计数模式，计数脉冲由外部引脚T0或T1引入。</li>
<li><strong>M0/M1</strong>：工作方式控制位，用于设置定时/计数器的工作方式，如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>M0</th>
<th>M1</th>
<th>工作方式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>方式0</td>
<td>13位计数器</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>方式1</td>
<td>16位计数器</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>方式2</td>
<td>8位重装计数器</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>方式3</td>
<td>定时器0分为两个独立8位计数器</td>
</tr>
</tbody></table>
<h4 id="T0、T1"><a href="#T0、T1" class="headerlink" title="T0、T1"></a>T0、T1</h4><p>**T0、T1(Timer)**，两个定时/计时器的初始赋值寄存器，不可位寻址，用于存放定时/计数的初始值。它们是两个16位寄存器，均可分为两个独立的8位寄存器，高8位记为TH，即TH0、TH1，低8位记为TL，即TL0、TL1。使用定时/计数器时，当外部或系统时钟振荡器输入一个脉冲时，对应寄存器的值便自动加1。</p>
<p>编程时需要注意，16位计数初始值要分两次写入对应初始值寄存器。</p>
<h3 id="定时-计数过程"><a href="#定时-计数过程" class="headerlink" title="定时/计数过程"></a>定时/计数过程</h3><p>51单片机定时/计数器的工作模式、工作方式、计数初始值及启停操作均需要在使用前进行初始化。</p>
<p>首先是通过TMOD中的GATE位来设置定时/计数器T0/T1的启动操作方式，工作在定时还是计数模式则是通过C/T位来设置。其次就是选择它们的工作方式。</p>
<p>工作方式0、1、3为非自动重装方式，在初始化程序和对应中断服务程序中均需要对初始数据寄存器THi、TLi装载。方式0是一个13位定时/计数器，只用了16位寄存器的<strong>高8位THi和TLi的低5位0~4位</strong>，TLi高3位未用，装入数据时需要注意。方式1为16位寄存器。</p>
<p>方式3只适用于定时/计数器T0，一般在<strong>定时/计时器T1作串行口波特率发生器时</strong>，才会选择这个工作模式。此时T0拆分为两个独立8位计数寄存器TH0和TL0，其中TL0下为8位定时/计数器，操作方式同方式0、1；TH0只做简单的内部定时功能，它借用定时/计时器1的控制位TR1和溢出标志位TF1，占用T1的中断资源，启动和停止也仅受TR1控制，此时T1仅可用在不需要中断的场合。</p>
<p>方式2为8位重装寄方式，仅由TLi作为工作寄存器，THi的值一直保持不变。TLi溢出时，THi的值作为装载值由CPU自动装入TLi，自动完成计数值初始化。所以此种方式下需要初始化时在THi和TLi中放入相同的计数值。</p>
<p>T0/T1寄存器中的初值X与定时/计数器的工作方式、工作模式有关。</p>
<p>在工作方式0下，为13位寄存器，也就是说最大的计数值M=$2^{13}$=8192，超过这个数字就会溢出，触发中断。工作方式为1下，为16位寄存器，M=$2^{16}$=65536。工作方式为2下，为8位寄存器，M=$2^{8}$=256。工作方式为3下，定时/计数器0分为高8位和低8位两个独立8位计数器，THi、TLi的M均为$2^{8}$=256。</p>
<p>不管是进行定时还是计数模式，其具体实现都是归结于计数。</p>
<p>计数模式下，是对外部脉冲数计数，<strong>初值X = M - 计数值</strong>。定时模式下，是对机器周期进行计数，**初值X = M - 计数值 = M - $\frac{定时时间T_c}{机器周期T_p}$ = M - $\frac{定时时间T_c × 晶振频率}{12}$**。</p>
<p>最后，中断中的相关寄存器也需要进行设置，设置TRi=1，来启动定时/计数器。</p>
<h3 id="定时-计数程序编写"><a href="#定时-计数程序编写" class="headerlink" title="定时/计数程序编写"></a>定时/计数程序编写</h3><p>通过上面对定时/计数过程的分析，可知编写想关功能程序时，要先进行初始化，再根据公式计算出定时初值并装载。</p>
<p>定时/计数程序基本编写格式如下：</p>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">      ;中断入口设置</span><br><span class="line">      ORG 0000H   ;起始地址</span><br><span class="line">      LJMP MAIN   ;跳转到主程序</span><br><span class="line">      ORG 000BH   ;中断入口地址2</span><br><span class="line">      LJMP INT2    ;跳转到定时器0中断服务程序</span><br><span class="line">      ORG 001BH   ;中断入口地址4</span><br><span class="line">      LJMP INT4    ;跳转到定时器1中断服务程序</span><br><span class="line"></span><br><span class="line">      ;主程序</span><br><span class="line">      ORG 0030H   ;起始地址</span><br><span class="line">MAIN: MOV TMOD, #xxH   ;设置工作模式，方式</span><br><span class="line">      MOV TH0, #xxH   ;计数初值，高八位</span><br><span class="line">      MOV TL0, #xxH   ;低八位</span><br><span class="line">      SETB EA   ;EA=1 ，开启总中断</span><br><span class="line">      SETB ET0   ;ET0=1，允许定时/计数器中断</span><br><span class="line">      SETB TR0   ;TR0=1，启动定时/计数器</span><br><span class="line">      ……</span><br><span class="line">LOOP: NOP</span><br><span class="line">      LJMP LOOP   ;死循环</span><br><span class="line"></span><br><span class="line">      ;中断服务程序</span><br><span class="line">      ORG 0100H   ;起始地址</span><br><span class="line">INT2: PUSH ACC   ;保存原来状态，下同</span><br><span class="line">      PUSH PSW  ;</span><br><span class="line">      MOV TH0, #xxH   ;重新赋计数初值（非重装方式下）</span><br><span class="line">      MOV TL0, #xxH   </span><br><span class="line">      ……</span><br><span class="line">INT4: ……</span><br><span class="line">      ……</span><br><span class="line">      POP PSW   ;恢复原始状态，下同</span><br><span class="line">      POP ACC   ;</span><br><span class="line">      RETI            ;中断返回</span><br><span class="line"></span><br><span class="line">      END            ;结束</span><br></pre></td></tr></table></figure>

<p>C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  TMOD = <span class="number">0</span>xxx;  <span class="comment">//注释同汇编</span></span><br><span class="line">  TH0 = <span class="number">0</span>xxx;</span><br><span class="line">  TL0 = <span class="number">0</span>xxx;</span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">  ET0 = <span class="number">1</span>;</span><br><span class="line">  TR0 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">int2</span><span class="params">()</span> interrupt 1&#123;  <span class="comment">// 定时器0中断服务程序</span></span><br><span class="line">  TH0 = <span class="number">0</span>xxx;</span><br><span class="line">  TL0 = <span class="number">0</span>xxx;</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="串口通信"><a href="#串口通信" class="headerlink" title="串口通信"></a>串口通信</h2><h3 id="通信相关概念"><a href="#通信相关概念" class="headerlink" title="通信相关概念"></a>通信相关概念</h3><p>计算机通信方式可以分为<strong>并行（Parallel）</strong>与<strong>串行（Serial）</strong>通信两大类，它将计算机技术和通信技术的相结合，完成计算机与外部设备或计算机与计算机之间的信息交换：</p>
<ul>
<li><p>并行通信：数据的各个二进制位在不同的数据线上同时传输。这样传输速度快，效率高，但所需的数据线多，成本高，抗干扰能力较差，适用于近距离传输。</p>
</li>
<li><p>串行通信：将数据拆分成多个二进制位，逐一的在同一条数据线上输出。虽然这样传输速度较慢，效率较低，但所需的数据线少、硬件电路简单、抗干扰能力强，且适用于远距离数据传输。</p>
</li>
</ul>
<p>串行通信又分为<strong>同步（Synchronous）</strong>通信和<strong>异步（Asynchronous）</strong>通信两种方式：</p>
<ul>
<li><p>同步通信：串行连续地传输数据，待发送的若干个字符数据构成一个数据块，在该数据块前部添加1~2个同步字符，在数据块的末尾添加校验信息，以此种方式构成数据帧，以数据帧为单位进行串行通信。</p>
</li>
<li><p>异步通信：每个字符数据被封装成帧，之后以帧的形式发送。每一帧由四部分构成，分别是起始位、数据位、校验位和停止位。起始位是数据开始传送的标志，用逻辑0表示；数据位紧跟起始位，通常是5~8位二进制位；校验位用于校验数据位是否发送正确，可以选择奇校验、偶校验或者不使用校验位。帧和帧之间可以连续，或者加入任意的空闲位，空闲位用逻辑1表示。</p>
</li>
</ul>
<p>串行数据的传输制式可分为<strong>单工（Simplex）</strong>、<strong>半双工（Half Duplex）</strong>、<strong>全双工（Full Duplex）</strong>。</p>
<ul>
<li>单工：数据传输仅能沿一个方向，不能实现反向传输。</li>
<li>半双工：数据传输可以沿两个方向，但需要分时进行。</li>
<li>全双工：数据可以同时进行双向传输。</li>
</ul>
<p>串行通信的错误校验方式有<strong>奇偶校验（Parity Check）</strong>、<strong>代码和校验</strong>、<strong>循环冗余校验（Cyclical Redundancy Check，CRC）</strong>三种：</p>
<ul>
<li>奇偶校验：在发送数据时，数据位尾随的1位为奇偶校验位（1或0）。奇校验时，数据中“1”的个数与校验位“1”的个数之和应为奇数；偶校验时，数据中“1”的个数与校验位“1”的个数之和应为偶数。接收字符时，对“1”的个数进行校验，若发现不一致，则说明传输数据过程中出现了差错。</li>
<li>代码和校验：发送方将所发数据块求和（或各字节异或），产生一个字节的校验字符（校验和）附加到数据块末尾。接收方接收数据同时对数据块（除校验字节外）求和（或各字节异或），将所得的结果与发送方的“校验和”进行比较，相符则无差错，否则即认为传送过程中出现了差错。</li>
<li>循环冗余校验：通过某种数学运算实现有效信息与校验位之间的循环校验，常用于对磁盘信息的传输、存储区的完整性校验等。这种校验方法纠错能力强，广泛应用于同步通信中。</li>
</ul>
<p><strong>波特率（Baud Rate）</strong>是串口通信时每秒钟传输二进制代码的位数，单位是位／秒（bps）。</p>
<p>51单片机的串行接口是一个全双工通信接口，即能够同时进行数据发送和接收。它可作通用异步收发传输器（Universal Asynchronous Receiver/Transmitter，UART）用，也可以作同步移位寄存器。其结构如下：</p>
<p><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411113631.png" alt="串行口结构"></p>
<h3 id="相关寄存器-2"><a href="#相关寄存器-2" class="headerlink" title="相关寄存器"></a>相关寄存器</h3><p>除前面介绍过的中断及定时/计数器相关寄存器外，SFR中与串口通信相关的寄存器有：</p>
<h4 id="SCON"><a href="#SCON" class="headerlink" title="SCON"></a>SCON</h4><p>**SCON(Serial Control)**，串行口控制寄存器，可位寻址，其各位定义如下：</p>
<p>位地址 | 9FH | 9EH | 9DH | 9CH | 9BH | 9AH | 99H | 98H<br>——|——|——|——|——|——|——|——|——|——<br>定义     | SM0 | SM1 | SM2 | REN | TB8 | RB8 | TI | RI</p>
<ul>
<li>**SM0和SM1(Serial Mode)**：串行口工作方式控制位，用于设置串行口工作方式，如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>SM0</th>
<th>SM1</th>
<th>工作方式</th>
<th>功能</th>
<th>波特率</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>方式0</td>
<td>8位同步移位寄存器</td>
<td>晶振频率/12</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>方式1</td>
<td>10位UART</td>
<td>可变</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>方式2</td>
<td>11位UART</td>
<td>晶振频率/64 或 /32</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>方式3</td>
<td>11位UART</td>
<td>可变</td>
</tr>
</tbody></table>
<ul>
<li><strong>SM2</strong>：多机通讯控制位，主要在以上工作方式为2或3下使用，工作方式0或1下都应该设为“0”状态。</li>
<li>**REN(Receive Enable)**：串行允许接收位，REN=1，允许接受数据。</li>
<li>**TB8(Transfer Bit 8)**：工作方式为2或3下存放发送数据的第9位，由软件置”0”或”1”。</li>
<li>**RB8(Receive Bit 8)**：工作方式为2或3下存放接受数据的第9位。方式0下不使用；方式1下，当SM2=0时，用于存放接收到的停止位。</li>
<li><strong>TI(Transfer Interrupt)<strong>：发送中断标志位，用于指示一帧数据是否发送完成。</strong>使用前必须软件复位为“0”</strong>，发送完一帧数据后硬件将自动置”1”。</li>
<li><strong>RI(Receive Interrupt)<strong>：接受中断标志位，用于指示一帧数据是否接受完成。接受完一帧数据后硬件将自动置”1”，</strong>之后必须软件复位为“0”</strong>。</li>
</ul>
<h4 id="SBUF"><a href="#SBUF" class="headerlink" title="SBUF"></a>SBUF</h4><p>**SBUF(Serial Data Buffer)**，串行数据缓冲器，不可位寻址。串行口两个SBUF，分别为发送寄存器和接收寄存器，它们在物理结构上是完全独立的，在SFR中的字节地址都是99H。这个重叠的地址靠读/写指令区分：串行发送时，CPU向SBUF写入数据，此时99H表示发送SBUF；串行接收时，CPU从SBUF读出数据，此时99H表示接收SBUF。</p>
<h4 id="PCON"><a href="#PCON" class="headerlink" title="PCON"></a>PCON</h4><p>**PCON(Power Control)**，电源控制寄存器，不可位寻址，其中只有一位与串口设置有关，其余都用于电源控制。其各位定义如下：</p>
<p>位号 | D7H | D6H | D5H | D4H | D3H | D2H | D1H | D0H<br>——|——|——|——|——|——|——|——|——|——<br>定义     | SMOD | - | - | - | GF1 | GF0 | PD | IDL</p>
<ul>
<li>**SMOD(Serial Mode)**：波特率选择位。工作方式1、2、3下串行通信波特率与$2^{SMOD}$成正比。也就是SMOD=1，通信波特率可提高一倍。</li>
<li>GF0/GF1(General Flag)：通用标志位，用户可自由使用</li>
<li>PD(Power Down)：掉电控制位。PD=0，单片机正常工作；PD=1，进入掉电模式，外部晶振停振，CPU、定时器、串行口全部停止工作，只有外部中断工作。在该模式下，只有硬件复位和上电能够唤醒单片机。</li>
<li>IDL(Idle)：空闲控制位。IDL=0，单片机正常工作；IDL=1，单片机进入空闲模式，除CPU不工作外，其余仍继续工作，在空闲模式下可由任一个中断或硬件复位唤醒。</li>
</ul>
<h3 id="串行通信过程"><a href="#串行通信过程" class="headerlink" title="串行通信过程"></a>串行通信过程</h3><p>一般情况下，当CPU允许接收（REN=1）且接收中断标志RI复位时，就启动一次接收过程。外界数据通过引脚RXD（P3.0）串行输入，数据最低位首先输入一个大小为9位移位寄存器，当一帧数据接收完毕后再并行送入接收SBUF中，同时RI也置“1”。当用软件读取完数据并复位RI后，才进行下一次操作。</p>
<p>当发送中断标志TI复位后，CPU便开始执行一条写SBUF指令，启动一次发送过程，发送控制器同时启动，并开始发送数据。发送的数据通过引脚TXD（P3.1）输出，首先输出最低位。当一帧数据发送完毕即发送SBUF为空时，CPU自动将TI值“1”。使用软件将TI复位，才执行下一个发送过程。</p>
<p>51单片机串行口有4种工作方式，通过SCON寄存器中的SM0、SM1口选择。</p>
<p>方式0下，串行口为<strong>同步移位寄存器的输入输出方式</strong>，主要用于和外部同步移位寄存器外接，以达到扩展一个并行输入或输出口的目的。这种方式下，数据从RXD端串行输入或输出，同步移位信号从TXD输出，波特率固定为晶振频率的1/12。TXD引脚每输出一位同步移位脉冲，数据就由RXD引脚输入或输出一个二进制位，发送和接收均为8位数据，低位在先，高位在后，没有起始位和停止位。此时，SM2、RB8、TB8均设为“0”，不起作用。方式0工作时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411113648.png" alt="方式0工作时序"></p>
<p>方式1下，串行口为<strong>10位异步通信方式</strong>，即1个起始位、8个有效数据位和1个停止位，波特率由定时/计数器T1溢出率及PCON中的SMOD位共同决定。进行发送操作时，发送电路会自动在8位发送数据前后分别加上一位起始位和一位停止位。接收操作时，接收器以所选择波特率的16倍速率采样RXD引脚电平，检测负跳变时，则说明起始位有效，将其移入输入移位寄存器，并开始接收这一帧信息的其余位。接收过程中，数据从输入移位寄存器右边移入，起始位移至输入移位寄存器最左边时，控制电路进行最后一次移位，随后将接收到的9位数据的前8位数据装入接收SBUF，第9位（停止位）进入RB8，并置RI=1，向CPU申请中断。如果上述条件不满足，数据则会被舍弃。此时，SM2也要设为“0”。方式1工作时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210411113701.png" alt="方式1工作时序"></p>
<p>方式2及方式3下，串行口都为<strong>11为异步收发方式</strong>，即1个起始位、8个有效数据位、1个附加数据位和1个停止位，其两者的差异在于通信波特率的不同：方式2的波特率取决于晶振频率和PCON中的SMOD位，固定为晶振频率的1/64或1/32；方式3的波特率由定时器T1的溢出率和SMOD位共同决定，故其波特率是可调的。比方式1多出来的一个附加位发送时为SCON中的TB8，接收时为RB8，由用户安排，可作奇偶校验位，也可作其他控制位。这两种方式很适合主从式的通信结构，在多机通讯时，主机的SM2位设为“0”，而从机的SM2位设为“1”，以便之间相互识别。</p>
<p>方式0下：$$波特率 = \frac{晶振频率 f_{osc}}{12}$$</p>
<p>方式2下：$$波特率 = \frac{2^{SMOD}}{64} *  f_{osc}$$</p>
<p>方式1下及方式3下，波特率都由定时/计数器T1溢出率及PCON中的SMOD位共同决定。T1的溢出率又取决于计数速率和计数值。定时模式下，计数速率为晶振频率的1/12；计数模式下，计数速率取决于外部输入时钟频率，但不可超过晶振频率的1/24。作波特率发生器时，T1通常设置为定时模式，工作在工作方式2下，作8位重装寄存器，此时波特率计算公式为：$$ {T1溢出周期 = 定时时间 = \frac{12}{f_{osc}} * (256 - 计数初值X) }$$<br>$$ T1溢出率 = \frac{1}{T1溢出周期} $$<br>$$ {波特率 = \frac{2^{SMOD}}{32} *  T1溢出率 } = \frac{2^{SMOD} * f_{osc}}{384 * (256 - X)}$$</p>
<p>则T1的计数初值，也就是装载值为：<br>$$ {计数初值X = 256 - \frac{2^{SMOD} * f_{osc}}{384 * 波特率}}$$</p>
<h3 id="串行通信程序编写"><a href="#串行通信程序编写" class="headerlink" title="串行通信程序编写"></a>串行通信程序编写</h3><p>由串行通信的基本过程可知，在使用串行口之前需要对串行口进行初始化，确定使用的工作方式并进行相关配置。</p>
<p>串行通信程序基本编写格式如下：</p>
<p>汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">      ;中断入口设置</span><br><span class="line">      ORG 0000H   ;起始地址</span><br><span class="line">      LJMP MAIN   ;跳转到主程序</span><br><span class="line">      ORG 0023H    ;中断入口地址5</span><br><span class="line">      LJMP INT5    ;跳转到串口中断服务程序</span><br><span class="line"></span><br><span class="line">      ;主程序</span><br><span class="line">      ORG 0030H   ;起始地址</span><br><span class="line">MAIN: MOV TMOD, #20H   ;设置定时/计数器T1工作模式为定时，工作方式2</span><br><span class="line">      MOV TH1, #F4H   ;计数初值，高八位，波特率2400</span><br><span class="line">      MOV TL1, #F4H   ;低八位</span><br><span class="line">      MOV SCON, #90H   ;设置串行口工作方式2，单机，允许接收</span><br><span class="line">      MOV PCON, #00H   ;波特率不加倍</span><br><span class="line">      SETB EA   ;EA=1 ，开启总中断</span><br><span class="line">      SETB ES   ;ES=1,开启串口中断</span><br><span class="line">      SETB TR1   ;TR1=1，启动定时/计数器</span><br><span class="line">      ……</span><br><span class="line">SEND: MOV A, #xxH   ;待发送数据放入A，即刻生成了偶校验位放在P中</span><br><span class="line">      MOV C, P   ;将偶校验位放入位寄存器C</span><br><span class="line">      CPL C   ;奇校验则把P取反</span><br><span class="line">      MOV TB8, C   ;将校验位放入TB8中</span><br><span class="line">      MOV SUBF, A   ;发送数据</span><br><span class="line">      JBC TI, xxx  ;发送完一帧数据后清除TI并进行下一步</span><br><span class="line">LOOP: NOP</span><br><span class="line">      LJMP LOOP   ;死循环</span><br><span class="line"></span><br><span class="line">      ;中断服务程序</span><br><span class="line">      ORG 0100H   ;起始地址</span><br><span class="line">INT5: MOV A, SBUF    ;取出接收到的数据</span><br><span class="line">      JB RB8, ERR   ;进行校验，不同则跳转到错误处理</span><br><span class="line">      CLR RI   ;复位，准备下次接收</span><br><span class="line">      ……</span><br><span class="line">      RETI            ;中断返回</span><br><span class="line"> ERR: ……</span><br><span class="line">      ……</span><br><span class="line">      END            ;结束</span><br></pre></td></tr></table></figure>

<p>C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reg51.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">  TMOD = <span class="number">0x20</span>H;  <span class="comment">//注释同汇编</span></span><br><span class="line">  TH0 = <span class="number">0xF4</span>;</span><br><span class="line">  TL0 = <span class="number">0xF4</span>;</span><br><span class="line">  SCON = <span class="number">0x90</span>;</span><br><span class="line">  PCON = <span class="number">0x00</span>;</span><br><span class="line">  EA = <span class="number">1</span>;</span><br><span class="line">  ES = <span class="number">1</span>;</span><br><span class="line">  TR1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    send(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">send</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data)</span> &#123;</span><br><span class="line">  ACC = data;</span><br><span class="line">  TB8 = P;</span><br><span class="line">  SBUF = data;</span><br><span class="line">  <span class="keyword">while</span>(!TI == <span class="number">0</span>)&#123;</span><br><span class="line">    ……</span><br><span class="line">    TI = <span class="number">0</span>；</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断处理程序，接收数据</span></span><br><span class="line"><span class="type">void</span> int5() interrupt <span class="number">5</span>&#123;  <span class="comment">// 定时器0中断服务程序</span></span><br><span class="line">  ACC = SBUF;</span><br><span class="line">  RI = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (RB8 == p)&#123;</span><br><span class="line">  ……</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  ……</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>  更新历史：</p>
<ul>
<li>2017.11.27 完成初稿</li>
</ul>
</div><div class="article-licensing box"><div class="licensing-title"><p>单片机原理(3)：中断、定时/计数、串行通信</p><p><a href="https://hugsy.top/2017/11/24/EE/msc51_3/">https://hugsy.top/2017/11/24/EE/msc51_3/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Hugsy</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2017-11-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-12-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/EE/">EE</a><a class="link-muted mr-2" rel="tag" href="/tags/MCU/">MCU</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210410180700.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210410180901.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2017/11/27/EE/msc51_4/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">单片机原理(4)：系统扩展、外围接口</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2017/11/22/EE/msc51_2/"><span class="level-item">单片机原理(2)：程序设计</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "87141cd4d6c3f44680bd6f9464996f14",
            repo: "Picbed",
            owner: "Hugsy19",
            clientID: "a321e46c668dc3d86c4f",
            clientSecret: "0ff9e81865b09e7511ef7ef17bb9596834b8fd95",
            admin: ["Hugsy19"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            proxy: "https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token",
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><!--!--><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/logo.svg" alt="Cornfield Chase" height="28"></a><p class="is-size-7"><span>&copy; 2022 Hugsy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>